{"version":3,"file":"static/chunks/45.6ef653c04d04cee9.js","mappings":"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","sources":["webpack://_N_E/./node_modules/.pnpm/livekit-client@2.9.5/node_modules/livekit-client/node_modules/.pnpm/loglevel@1.9.2/node_modules/loglevel/lib/loglevel.js","webpack://_N_E/./node_modules/.pnpm/livekit-client@2.9.5/node_modules/livekit-client/src/logger.ts","webpack://_N_E/./node_modules/.pnpm/livekit-client@2.9.5/node_modules/livekit-client/node_modules/.pnpm/@livekit+mutex@1.1.1/node_modules/@livekit/mutex/dist/index.mjs","webpack://_N_E/./node_modules/.pnpm/livekit-client@2.9.5/node_modules/livekit-client/src/utils/AsyncQueue.ts","webpack://_N_E/./node_modules/.pnpm/livekit-client@2.9.5/node_modules/livekit-client/src/e2ee/constants.ts","webpack://_N_E/./node_modules/.pnpm/livekit-client@2.9.5/node_modules/livekit-client/src/room/errors.ts","webpack://_N_E/./node_modules/.pnpm/livekit-client@2.9.5/node_modules/livekit-client/src/e2ee/errors.ts","webpack://_N_E/./node_modules/.pnpm/livekit-client@2.9.5/node_modules/livekit-client/src/e2ee/events.ts","webpack://_N_E/./node_modules/.pnpm/livekit-client@2.9.5/node_modules/livekit-client/node_modules/.pnpm/events@3.3.0/node_modules/events/events.js","webpack://_N_E/./node_modules/.pnpm/livekit-client@2.9.5/node_modules/livekit-client/src/e2ee/utils.ts","webpack://_N_E/./node_modules/.pnpm/livekit-client@2.9.5/node_modules/livekit-client/src/e2ee/worker/SifGuard.ts","webpack://_N_E/./node_modules/.pnpm/livekit-client@2.9.5/node_modules/livekit-client/src/e2ee/worker/FrameCryptor.ts","webpack://_N_E/./node_modules/.pnpm/livekit-client@2.9.5/node_modules/livekit-client/src/e2ee/worker/ParticipantKeyHandler.ts","webpack://_N_E/./node_modules/.pnpm/livekit-client@2.9.5/node_modules/livekit-client/src/e2ee/worker/e2ee.worker.ts"],"sourcesContent":["/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/\n(function (root, definition) {\n    \"use strict\";\n    if (typeof define === 'function' && define.amd) {\n        define(definition);\n    } else if (typeof module === 'object' && module.exports) {\n        module.exports = definition();\n    } else {\n        root.log = definition();\n    }\n}(this, function () {\n    \"use strict\";\n\n    // Slightly dubious tricks to cut down minimized file size\n    var noop = function() {};\n    var undefinedType = \"undefined\";\n    var isIE = (typeof window !== undefinedType) && (typeof window.navigator !== undefinedType) && (\n        /Trident\\/|MSIE /.test(window.navigator.userAgent)\n    );\n\n    var logMethods = [\n        \"trace\",\n        \"debug\",\n        \"info\",\n        \"warn\",\n        \"error\"\n    ];\n\n    var _loggersByName = {};\n    var defaultLogger = null;\n\n    // Cross-browser bind equivalent that works at least back to IE6\n    function bindMethod(obj, methodName) {\n        var method = obj[methodName];\n        if (typeof method.bind === 'function') {\n            return method.bind(obj);\n        } else {\n            try {\n                return Function.prototype.bind.call(method, obj);\n            } catch (e) {\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                return function() {\n                    return Function.prototype.apply.apply(method, [obj, arguments]);\n                };\n            }\n        }\n    }\n\n    // Trace() doesn't print the message in IE, so for that case we need to wrap it\n    function traceForIE() {\n        if (console.log) {\n            if (console.log.apply) {\n                console.log.apply(console, arguments);\n            } else {\n                // In old IE, native console methods themselves don't have apply().\n                Function.prototype.apply.apply(console.log, [console, arguments]);\n            }\n        }\n        if (console.trace) console.trace();\n    }\n\n    // Build the best logging method possible for this env\n    // Wherever possible we want to bind, not wrap, to preserve stack traces\n    function realMethod(methodName) {\n        if (methodName === 'debug') {\n            methodName = 'log';\n        }\n\n        if (typeof console === undefinedType) {\n            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n        } else if (methodName === 'trace' && isIE) {\n            return traceForIE;\n        } else if (console[methodName] !== undefined) {\n            return bindMethod(console, methodName);\n        } else if (console.log !== undefined) {\n            return bindMethod(console, 'log');\n        } else {\n            return noop;\n        }\n    }\n\n    // These private functions always need `this` to be set properly\n\n    function replaceLoggingMethods() {\n        /*jshint validthis:true */\n        var level = this.getLevel();\n\n        // Replace the actual methods.\n        for (var i = 0; i < logMethods.length; i++) {\n            var methodName = logMethods[i];\n            this[methodName] = (i < level) ?\n                noop :\n                this.methodFactory(methodName, level, this.name);\n        }\n\n        // Define log.log as an alias for log.debug\n        this.log = this.debug;\n\n        // Return any important warnings.\n        if (typeof console === undefinedType && level < this.levels.SILENT) {\n            return \"No console available for logging\";\n        }\n    }\n\n    // In old IE versions, the console isn't present until you first open it.\n    // We build realMethod() replacements here that regenerate logging methods\n    function enableLoggingWhenConsoleArrives(methodName) {\n        return function () {\n            if (typeof console !== undefinedType) {\n                replaceLoggingMethods.call(this);\n                this[methodName].apply(this, arguments);\n            }\n        };\n    }\n\n    // By default, we use closely bound real methods wherever possible, and\n    // otherwise we wait for a console to appear, and then try again.\n    function defaultMethodFactory(methodName, _level, _loggerName) {\n        /*jshint validthis:true */\n        return realMethod(methodName) ||\n               enableLoggingWhenConsoleArrives.apply(this, arguments);\n    }\n\n    function Logger(name, factory) {\n      // Private instance variables.\n      var self = this;\n      /**\n       * The level inherited from a parent logger (or a global default). We\n       * cache this here rather than delegating to the parent so that it stays\n       * in sync with the actual logging methods that we have installed (the\n       * parent could change levels but we might not have rebuilt the loggers\n       * in this child yet).\n       * @type {number}\n       */\n      var inheritedLevel;\n      /**\n       * The default level for this logger, if any. If set, this overrides\n       * `inheritedLevel`.\n       * @type {number|null}\n       */\n      var defaultLevel;\n      /**\n       * A user-specific level for this logger. If set, this overrides\n       * `defaultLevel`.\n       * @type {number|null}\n       */\n      var userLevel;\n\n      var storageKey = \"loglevel\";\n      if (typeof name === \"string\") {\n        storageKey += \":\" + name;\n      } else if (typeof name === \"symbol\") {\n        storageKey = undefined;\n      }\n\n      function persistLevelIfPossible(levelNum) {\n          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\n\n          if (typeof window === undefinedType || !storageKey) return;\n\n          // Use localStorage if available\n          try {\n              window.localStorage[storageKey] = levelName;\n              return;\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n          } catch (ignore) {}\n      }\n\n      function getPersistedLevel() {\n          var storedLevel;\n\n          if (typeof window === undefinedType || !storageKey) return;\n\n          try {\n              storedLevel = window.localStorage[storageKey];\n          } catch (ignore) {}\n\n          // Fallback to cookies if local storage gives us nothing\n          if (typeof storedLevel === undefinedType) {\n              try {\n                  var cookie = window.document.cookie;\n                  var cookieName = encodeURIComponent(storageKey);\n                  var location = cookie.indexOf(cookieName + \"=\");\n                  if (location !== -1) {\n                      storedLevel = /^([^;]+)/.exec(\n                          cookie.slice(location + cookieName.length + 1)\n                      )[1];\n                  }\n              } catch (ignore) {}\n          }\n\n          // If the stored level is not valid, treat it as if nothing was stored.\n          if (self.levels[storedLevel] === undefined) {\n              storedLevel = undefined;\n          }\n\n          return storedLevel;\n      }\n\n      function clearPersistedLevel() {\n          if (typeof window === undefinedType || !storageKey) return;\n\n          // Use localStorage if available\n          try {\n              window.localStorage.removeItem(storageKey);\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + \"=; expires=Thu, 01 Jan 1970 00:00:00 UTC\";\n          } catch (ignore) {}\n      }\n\n      function normalizeLevel(input) {\n          var level = input;\n          if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\n              level = self.levels[level.toUpperCase()];\n          }\n          if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\n              return level;\n          } else {\n              throw new TypeError(\"log.setLevel() called with invalid level: \" + input);\n          }\n      }\n\n      /*\n       *\n       * Public logger API - see https://github.com/pimterry/loglevel for details\n       *\n       */\n\n      self.name = name;\n\n      self.levels = { \"TRACE\": 0, \"DEBUG\": 1, \"INFO\": 2, \"WARN\": 3,\n          \"ERROR\": 4, \"SILENT\": 5};\n\n      self.methodFactory = factory || defaultMethodFactory;\n\n      self.getLevel = function () {\n          if (userLevel != null) {\n            return userLevel;\n          } else if (defaultLevel != null) {\n            return defaultLevel;\n          } else {\n            return inheritedLevel;\n          }\n      };\n\n      self.setLevel = function (level, persist) {\n          userLevel = normalizeLevel(level);\n          if (persist !== false) {  // defaults to true\n              persistLevelIfPossible(userLevel);\n          }\n\n          // NOTE: in v2, this should call rebuild(), which updates children.\n          return replaceLoggingMethods.call(self);\n      };\n\n      self.setDefaultLevel = function (level) {\n          defaultLevel = normalizeLevel(level);\n          if (!getPersistedLevel()) {\n              self.setLevel(level, false);\n          }\n      };\n\n      self.resetLevel = function () {\n          userLevel = null;\n          clearPersistedLevel();\n          replaceLoggingMethods.call(self);\n      };\n\n      self.enableAll = function(persist) {\n          self.setLevel(self.levels.TRACE, persist);\n      };\n\n      self.disableAll = function(persist) {\n          self.setLevel(self.levels.SILENT, persist);\n      };\n\n      self.rebuild = function () {\n          if (defaultLogger !== self) {\n              inheritedLevel = normalizeLevel(defaultLogger.getLevel());\n          }\n          replaceLoggingMethods.call(self);\n\n          if (defaultLogger === self) {\n              for (var childName in _loggersByName) {\n                _loggersByName[childName].rebuild();\n              }\n          }\n      };\n\n      // Initialize all the internal levels.\n      inheritedLevel = normalizeLevel(\n          defaultLogger ? defaultLogger.getLevel() : \"WARN\"\n      );\n      var initialLevel = getPersistedLevel();\n      if (initialLevel != null) {\n          userLevel = normalizeLevel(initialLevel);\n      }\n      replaceLoggingMethods.call(self);\n    }\n\n    /*\n     *\n     * Top-level API\n     *\n     */\n\n    defaultLogger = new Logger();\n\n    defaultLogger.getLogger = function getLogger(name) {\n        if ((typeof name !== \"symbol\" && typeof name !== \"string\") || name === \"\") {\n            throw new TypeError(\"You must supply a name when creating a logger.\");\n        }\n\n        var logger = _loggersByName[name];\n        if (!logger) {\n            logger = _loggersByName[name] = new Logger(\n                name,\n                defaultLogger.methodFactory\n            );\n        }\n        return logger;\n    };\n\n    // Grab the current global log variable in case of overwrite\n    var _log = (typeof window !== undefinedType) ? window.log : undefined;\n    defaultLogger.noConflict = function() {\n        if (typeof window !== undefinedType &&\n               window.log === defaultLogger) {\n            window.log = _log;\n        }\n\n        return defaultLogger;\n    };\n\n    defaultLogger.getLoggers = function getLoggers() {\n        return _loggersByName;\n    };\n\n    // ES6 default export, for compatibility\n    defaultLogger['default'] = defaultLogger;\n\n    return defaultLogger;\n}));\n","import * as log from 'loglevel';\n\nexport enum LogLevel {\n  trace = 0,\n  debug = 1,\n  info = 2,\n  warn = 3,\n  error = 4,\n  silent = 5,\n}\n\nexport enum LoggerNames {\n  Default = 'livekit',\n  Room = 'livekit-room',\n  Participant = 'livekit-participant',\n  Track = 'livekit-track',\n  Publication = 'livekit-track-publication',\n  Engine = 'livekit-engine',\n  Signal = 'livekit-signal',\n  PCManager = 'livekit-pc-manager',\n  PCTransport = 'livekit-pc-transport',\n  E2EE = 'lk-e2ee',\n}\n\ntype LogLevelString = keyof typeof LogLevel;\n\nexport type StructuredLogger = log.Logger & {\n  trace: (msg: string, context?: object) => void;\n  debug: (msg: string, context?: object) => void;\n  info: (msg: string, context?: object) => void;\n  warn: (msg: string, context?: object) => void;\n  error: (msg: string, context?: object) => void;\n  setDefaultLevel: (level: log.LogLevelDesc) => void;\n  setLevel: (level: log.LogLevelDesc) => void;\n  getLevel: () => number;\n};\n\nlet livekitLogger = log.getLogger('livekit');\nconst livekitLoggers = Object.values(LoggerNames).map((name) => log.getLogger(name));\n\nlivekitLogger.setDefaultLevel(LogLevel.info);\n\nexport default livekitLogger as StructuredLogger;\n\n/**\n * @internal\n */\nexport function getLogger(name: string) {\n  const logger = log.getLogger(name);\n  logger.setDefaultLevel(livekitLogger.getLevel());\n  return logger as StructuredLogger;\n}\n\nexport function setLogLevel(level: LogLevel | LogLevelString, loggerName?: LoggerNames) {\n  if (loggerName) {\n    log.getLogger(loggerName).setLevel(level);\n  } else {\n    for (const logger of livekitLoggers) {\n      logger.setLevel(level);\n    }\n  }\n}\n\nexport type LogExtension = (level: LogLevel, msg: string, context?: object) => void;\n\n/**\n * use this to hook into the logging function to allow sending internal livekit logs to third party services\n * if set, the browser logs will lose their stacktrace information (see https://github.com/pimterry/loglevel#writing-plugins)\n */\nexport function setLogExtension(extension: LogExtension, logger?: StructuredLogger) {\n  const loggers = logger ? [logger] : livekitLoggers;\n\n  loggers.forEach((logR) => {\n    const originalFactory = logR.methodFactory;\n\n    logR.methodFactory = (methodName, configLevel, loggerName) => {\n      const rawMethod = originalFactory(methodName, configLevel, loggerName);\n\n      const logLevel = LogLevel[methodName as LogLevelString];\n      const needLog = logLevel >= configLevel && logLevel < LogLevel.silent;\n\n      return (msg, context?: [msg: string, context: object]) => {\n        if (context) rawMethod(msg, context);\n        else rawMethod(msg);\n        if (needLog) {\n          extension(logLevel, msg, context);\n        }\n      };\n    };\n    logR.setLevel(logR.getLevel());\n  });\n}\n\nexport const workerLogger = log.getLogger('lk-e2ee') as StructuredLogger;\n","var e = Object.defineProperty;\nvar h = (i, s, t) => s in i ? e(i, s, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[s] = t;\nvar o = (i, s, t) => h(i, typeof s != \"symbol\" ? s + \"\" : s, t);\nclass _ {\n  constructor() {\n    o(this, \"_locking\");\n    o(this, \"_locks\");\n    this._locking = Promise.resolve(), this._locks = 0;\n  }\n  isLocked() {\n    return this._locks > 0;\n  }\n  lock() {\n    this._locks += 1;\n    let s;\n    const t = new Promise(\n      (l) => s = () => {\n        this._locks -= 1, l();\n      }\n    ), c = this._locking.then(() => s);\n    return this._locking = this._locking.then(() => t), c;\n  }\n}\nclass n {\n  constructor(s) {\n    o(this, \"_queue\");\n    o(this, \"_limit\");\n    o(this, \"_locks\");\n    this._queue = [], this._limit = s, this._locks = 0;\n  }\n  isLocked() {\n    return this._locks >= this._limit;\n  }\n  async lock() {\n    return this.isLocked() ? new Promise((s) => {\n      this._queue.push(() => {\n        this._locks++, s(this._unlock.bind(this));\n      });\n    }) : (this._locks++, this._unlock.bind(this));\n  }\n  _unlock() {\n    if (this._locks--, this._queue.length && !this.isLocked()) {\n      const s = this._queue.shift();\n      s == null || s();\n    }\n  }\n}\nexport {\n  n as MultiMutex,\n  _ as Mutex\n};\n//# sourceMappingURL=index.mjs.map\n","import { Mutex } from '@livekit/mutex';\n\ntype QueueTask<T> = () => PromiseLike<T>;\n\nenum QueueTaskStatus {\n  'WAITING',\n  'RUNNING',\n  'COMPLETED',\n}\n\ntype QueueTaskInfo = {\n  id: number;\n  enqueuedAt: number;\n  executedAt?: number;\n  status: QueueTaskStatus;\n};\n\nexport class AsyncQueue {\n  private pendingTasks: Map<number, QueueTaskInfo>;\n\n  private taskMutex: Mutex;\n\n  private nextTaskIndex: number;\n\n  constructor() {\n    this.pendingTasks = new Map();\n    this.taskMutex = new Mutex();\n    this.nextTaskIndex = 0;\n  }\n\n  async run<T>(task: QueueTask<T>) {\n    const taskInfo: QueueTaskInfo = {\n      id: this.nextTaskIndex++,\n      enqueuedAt: Date.now(),\n      status: QueueTaskStatus.WAITING,\n    };\n    this.pendingTasks.set(taskInfo.id, taskInfo);\n    const unlock = await this.taskMutex.lock();\n    try {\n      taskInfo.executedAt = Date.now();\n      taskInfo.status = QueueTaskStatus.RUNNING;\n      return await task();\n    } finally {\n      taskInfo.status = QueueTaskStatus.COMPLETED;\n      this.pendingTasks.delete(taskInfo.id);\n      unlock();\n    }\n  }\n\n  async flush() {\n    return this.run(async () => {});\n  }\n\n  snapshot() {\n    return Array.from(this.pendingTasks.values());\n  }\n}\n","import type { KeyProviderOptions } from './types';\n\nexport const ENCRYPTION_ALGORITHM = 'AES-GCM';\n\n// How many consecutive frames can fail decrypting before a particular key gets marked as invalid\nexport const DECRYPTION_FAILURE_TOLERANCE = 10;\n\n// We copy the first bytes of the VP8 payload unencrypted.\n// For keyframes this is 10 bytes, for non-keyframes (delta) 3. See\n//   https://tools.ietf.org/html/rfc6386#section-9.1\n// This allows the bridge to continue detecting keyframes (only one byte needed in the JVB)\n// and is also a bit easier for the VP8 decoder (i.e. it generates funny garbage pictures\n// instead of being unable to decode).\n// This is a bit for show and we might want to reduce to 1 unconditionally in the final version.\n//\n// For audio (where frame.type is not set) we do not encrypt the opus TOC byte:\n//   https://tools.ietf.org/html/rfc6716#section-3.1\nexport const UNENCRYPTED_BYTES = {\n  key: 10,\n  delta: 3,\n  audio: 1, // frame.type is not set on audio, so this is set manually\n  empty: 0,\n} as const;\n\n/* We use a 12 byte bit IV. This is signalled in plain together with the\n packet. See https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters */\nexport const IV_LENGTH = 12;\n\n// flag set to indicate that e2ee has been setup for sender/receiver;\nexport const E2EE_FLAG = 'lk_e2ee';\n\nexport const SALT = 'LKFrameEncryptionKey';\n\nexport const KEY_PROVIDER_DEFAULTS: KeyProviderOptions = {\n  sharedKey: false,\n  ratchetSalt: SALT,\n  ratchetWindowSize: 8,\n  failureTolerance: DECRYPTION_FAILURE_TOLERANCE,\n  keyringSize: 16,\n} as const;\n\nexport const MAX_SIF_COUNT = 100;\nexport const MAX_SIF_DURATION = 2000;\n","import { DisconnectReason, RequestResponse_Reason } from '@livekit/protocol';\n\nexport class LivekitError extends Error {\n  code: number;\n\n  constructor(code: number, message?: string) {\n    super(message || 'an error has occured');\n    this.name = 'LiveKitError';\n    this.code = code;\n  }\n}\n\nexport enum ConnectionErrorReason {\n  NotAllowed,\n  ServerUnreachable,\n  InternalError,\n  Cancelled,\n  LeaveRequest,\n}\n\nexport class ConnectionError extends LivekitError {\n  status?: number;\n\n  context?: unknown | DisconnectReason;\n\n  reason: ConnectionErrorReason;\n\n  reasonName: string;\n\n  constructor(\n    message: string,\n    reason: ConnectionErrorReason,\n    status?: number,\n    context?: unknown | DisconnectReason,\n  ) {\n    super(1, message);\n    this.name = 'ConnectionError';\n    this.status = status;\n    this.reason = reason;\n    this.context = context;\n    this.reasonName = ConnectionErrorReason[reason];\n  }\n}\n\nexport class DeviceUnsupportedError extends LivekitError {\n  constructor(message?: string) {\n    super(21, message ?? 'device is unsupported');\n    this.name = 'DeviceUnsupportedError';\n  }\n}\n\nexport class TrackInvalidError extends LivekitError {\n  constructor(message?: string) {\n    super(20, message ?? 'track is invalid');\n    this.name = 'TrackInvalidError';\n  }\n}\n\nexport class UnsupportedServer extends LivekitError {\n  constructor(message?: string) {\n    super(10, message ?? 'unsupported server');\n    this.name = 'UnsupportedServer';\n  }\n}\n\nexport class UnexpectedConnectionState extends LivekitError {\n  constructor(message?: string) {\n    super(12, message ?? 'unexpected connection state');\n    this.name = 'UnexpectedConnectionState';\n  }\n}\n\nexport class NegotiationError extends LivekitError {\n  constructor(message?: string) {\n    super(13, message ?? 'unable to negotiate');\n    this.name = 'NegotiationError';\n  }\n}\n\nexport class PublishDataError extends LivekitError {\n  constructor(message?: string) {\n    super(14, message ?? 'unable to publish data');\n    this.name = 'PublishDataError';\n  }\n}\n\nexport class PublishTrackError extends LivekitError {\n  status: number;\n\n  constructor(message: string, status: number) {\n    super(15, message);\n    this.name = 'PublishTrackError';\n    this.status = status;\n  }\n}\n\nexport type RequestErrorReason =\n  | Exclude<RequestResponse_Reason, RequestResponse_Reason.OK>\n  | 'TimeoutError';\n\nexport class SignalRequestError extends LivekitError {\n  reason: RequestErrorReason;\n\n  reasonName: string;\n\n  constructor(message: string, reason: RequestErrorReason) {\n    super(15, message);\n    this.reason = reason;\n    this.reasonName = typeof reason === 'string' ? reason : RequestResponse_Reason[reason];\n  }\n}\n\nexport enum MediaDeviceFailure {\n  // user rejected permissions\n  PermissionDenied = 'PermissionDenied',\n  // device is not available\n  NotFound = 'NotFound',\n  // device is in use. On Windows, only a single tab may get access to a device at a time.\n  DeviceInUse = 'DeviceInUse',\n  Other = 'Other',\n}\n\nexport namespace MediaDeviceFailure {\n  export function getFailure(error: any): MediaDeviceFailure | undefined {\n    if (error && 'name' in error) {\n      if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {\n        return MediaDeviceFailure.NotFound;\n      }\n      if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {\n        return MediaDeviceFailure.PermissionDenied;\n      }\n      if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {\n        return MediaDeviceFailure.DeviceInUse;\n      }\n      return MediaDeviceFailure.Other;\n    }\n  }\n}\n","import { LivekitError } from '../room/errors';\n\nexport enum CryptorErrorReason {\n  InvalidKey = 0,\n  MissingKey = 1,\n  InternalError = 2,\n}\n\nexport class CryptorError extends LivekitError {\n  reason: CryptorErrorReason;\n\n  participantIdentity?: string;\n\n  constructor(\n    message?: string,\n    reason: CryptorErrorReason = CryptorErrorReason.InternalError,\n    participantIdentity?: string,\n  ) {\n    super(40, message);\n    this.reason = reason;\n    this.participantIdentity = participantIdentity;\n  }\n}\n","import type Participant from '../room/participant/Participant';\nimport type { CryptorError } from './errors';\nimport type { KeyInfo } from './types';\n\nexport enum KeyProviderEvent {\n  SetKey = 'setKey',\n  RatchetRequest = 'ratchetRequest',\n  KeyRatcheted = 'keyRatcheted',\n}\n\nexport type KeyProviderCallbacks = {\n  [KeyProviderEvent.SetKey]: (keyInfo: KeyInfo) => void;\n  [KeyProviderEvent.RatchetRequest]: (participantIdentity?: string, keyIndex?: number) => void;\n  [KeyProviderEvent.KeyRatcheted]: (material: CryptoKey, keyIndex?: number) => void;\n};\n\nexport enum KeyHandlerEvent {\n  KeyRatcheted = 'keyRatcheted',\n}\n\nexport type ParticipantKeyHandlerCallbacks = {\n  [KeyHandlerEvent.KeyRatcheted]: (\n    material: CryptoKey,\n    participantIdentity: string,\n    keyIndex?: number,\n  ) => void;\n};\n\nexport enum EncryptionEvent {\n  ParticipantEncryptionStatusChanged = 'participantEncryptionStatusChanged',\n  EncryptionError = 'encryptionError',\n}\n\nexport type E2EEManagerCallbacks = {\n  [EncryptionEvent.ParticipantEncryptionStatusChanged]: (\n    enabled: boolean,\n    participant: Participant,\n  ) => void;\n  [EncryptionEvent.EncryptionError]: (error: Error) => void;\n};\n\nexport type CryptorCallbacks = {\n  [CryptorEvent.Error]: (error: CryptorError) => void;\n};\n\nexport enum CryptorEvent {\n  Error = 'cryptorError',\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","import { ENCRYPTION_ALGORITHM } from './constants';\n\nexport function isE2EESupported() {\n  return isInsertableStreamSupported() || isScriptTransformSupported();\n}\n\nexport function isScriptTransformSupported() {\n  // @ts-ignore\n  return typeof window.RTCRtpScriptTransform !== 'undefined';\n}\n\nexport function isInsertableStreamSupported() {\n  return (\n    typeof window.RTCRtpSender !== 'undefined' &&\n    // @ts-ignore\n    typeof window.RTCRtpSender.prototype.createEncodedStreams !== 'undefined'\n  );\n}\n\nexport function isVideoFrame(\n  frame: RTCEncodedAudioFrame | RTCEncodedVideoFrame,\n): frame is RTCEncodedVideoFrame {\n  return 'type' in frame;\n}\n\nexport async function importKey(\n  keyBytes: Uint8Array | ArrayBuffer,\n  algorithm: string | { name: string } = { name: ENCRYPTION_ALGORITHM },\n  usage: 'derive' | 'encrypt' = 'encrypt',\n) {\n  // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey\n  return crypto.subtle.importKey(\n    'raw',\n    keyBytes,\n    algorithm,\n    false,\n    usage === 'derive' ? ['deriveBits', 'deriveKey'] : ['encrypt', 'decrypt'],\n  );\n}\n\nexport async function createKeyMaterialFromString(password: string) {\n  let enc = new TextEncoder();\n\n  const keyMaterial = await crypto.subtle.importKey(\n    'raw',\n    enc.encode(password),\n    {\n      name: 'PBKDF2',\n    },\n    false,\n    ['deriveBits', 'deriveKey'],\n  );\n\n  return keyMaterial;\n}\n\nexport async function createKeyMaterialFromBuffer(cryptoBuffer: ArrayBuffer) {\n  const keyMaterial = await crypto.subtle.importKey('raw', cryptoBuffer, 'HKDF', false, [\n    'deriveBits',\n    'deriveKey',\n  ]);\n\n  return keyMaterial;\n}\n\nfunction getAlgoOptions(algorithmName: string, salt: string) {\n  const textEncoder = new TextEncoder();\n  const encodedSalt = textEncoder.encode(salt);\n  switch (algorithmName) {\n    case 'HKDF':\n      return {\n        name: 'HKDF',\n        salt: encodedSalt,\n        hash: 'SHA-256',\n        info: new ArrayBuffer(128),\n      };\n    case 'PBKDF2': {\n      return {\n        name: 'PBKDF2',\n        salt: encodedSalt,\n        hash: 'SHA-256',\n        iterations: 100000,\n      };\n    }\n    default:\n      throw new Error(`algorithm ${algorithmName} is currently unsupported`);\n  }\n}\n\n/**\n * Derives a set of keys from the master key.\n * See https://tools.ietf.org/html/draft-omara-sframe-00#section-4.3.1\n */\nexport async function deriveKeys(material: CryptoKey, salt: string) {\n  const algorithmOptions = getAlgoOptions(material.algorithm.name, salt);\n\n  // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/deriveKey#HKDF\n  // https://developer.mozilla.org/en-US/docs/Web/API/HkdfParams\n  const encryptionKey = await crypto.subtle.deriveKey(\n    algorithmOptions,\n    material,\n    {\n      name: ENCRYPTION_ALGORITHM,\n      length: 128,\n    },\n    false,\n    ['encrypt', 'decrypt'],\n  );\n\n  return { material, encryptionKey };\n}\n\nexport function createE2EEKey(): Uint8Array {\n  return window.crypto.getRandomValues(new Uint8Array(32));\n}\n\n/**\n * Ratchets a key. See\n * https://tools.ietf.org/html/draft-omara-sframe-00#section-4.3.5.1\n */\nexport async function ratchet(material: CryptoKey, salt: string): Promise<ArrayBuffer> {\n  const algorithmOptions = getAlgoOptions(material.algorithm.name, salt);\n\n  // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/deriveBits\n  return crypto.subtle.deriveBits(algorithmOptions, material, 256);\n}\n\nexport function needsRbspUnescaping(frameData: Uint8Array) {\n  for (var i = 0; i < frameData.length - 3; i++) {\n    if (frameData[i] == 0 && frameData[i + 1] == 0 && frameData[i + 2] == 3) return true;\n  }\n  return false;\n}\n\nexport function parseRbsp(stream: Uint8Array): Uint8Array {\n  const dataOut: number[] = [];\n  var length = stream.length;\n  for (var i = 0; i < stream.length; ) {\n    // Be careful about over/underflow here. byte_length_ - 3 can underflow, and\n    // i + 3 can overflow, but byte_length_ - i can't, because i < byte_length_\n    // above, and that expression will produce the number of bytes left in\n    // the stream including the byte at i.\n    if (length - i >= 3 && !stream[i] && !stream[i + 1] && stream[i + 2] == 3) {\n      // Two rbsp bytes.\n      dataOut.push(stream[i++]);\n      dataOut.push(stream[i++]);\n      // Skip the emulation byte.\n      i++;\n    } else {\n      // Single rbsp byte.\n      dataOut.push(stream[i++]);\n    }\n  }\n  return new Uint8Array(dataOut);\n}\n\nconst kZerosInStartSequence = 2;\nconst kEmulationByte = 3;\n\nexport function writeRbsp(data_in: Uint8Array): Uint8Array {\n  const dataOut: number[] = [];\n  var numConsecutiveZeros = 0;\n  for (var i = 0; i < data_in.length; ++i) {\n    var byte = data_in[i];\n    if (byte <= kEmulationByte && numConsecutiveZeros >= kZerosInStartSequence) {\n      // Need to escape.\n      dataOut.push(kEmulationByte);\n      numConsecutiveZeros = 0;\n    }\n    dataOut.push(byte);\n    if (byte == 0) {\n      ++numConsecutiveZeros;\n    } else {\n      numConsecutiveZeros = 0;\n    }\n  }\n  return new Uint8Array(dataOut);\n}\n","import { MAX_SIF_COUNT, MAX_SIF_DURATION } from '../constants';\n\nexport class SifGuard {\n  private consecutiveSifCount = 0;\n\n  private sifSequenceStartedAt: number | undefined;\n\n  private lastSifReceivedAt: number = 0;\n\n  private userFramesSinceSif: number = 0;\n\n  recordSif() {\n    this.consecutiveSifCount += 1;\n    this.sifSequenceStartedAt ??= Date.now();\n    this.lastSifReceivedAt = Date.now();\n  }\n\n  recordUserFrame() {\n    if (this.sifSequenceStartedAt === undefined) {\n      return;\n    } else {\n      this.userFramesSinceSif += 1;\n    }\n    if (\n      // reset if we received more user frames than SIFs\n      this.userFramesSinceSif > this.consecutiveSifCount ||\n      // also reset if we got a new user frame and the latest SIF frame hasn't been updated in a while\n      Date.now() - this.lastSifReceivedAt > MAX_SIF_DURATION\n    ) {\n      this.reset();\n    }\n  }\n\n  isSifAllowed() {\n    return (\n      this.consecutiveSifCount < MAX_SIF_COUNT &&\n      (this.sifSequenceStartedAt === undefined ||\n        Date.now() - this.sifSequenceStartedAt < MAX_SIF_DURATION)\n    );\n  }\n\n  reset() {\n    this.userFramesSinceSif = 0;\n    this.consecutiveSifCount = 0;\n    this.sifSequenceStartedAt = undefined;\n  }\n}\n","/* eslint-disable @typescript-eslint/no-unused-vars */\n// TODO code inspired by https://github.com/webrtc/samples/blob/gh-pages/src/content/insertable-streams/endtoend-encryption/js/worker.js\nimport { EventEmitter } from 'events';\nimport type TypedEventEmitter from 'typed-emitter';\nimport { workerLogger } from '../../logger';\nimport type { VideoCodec } from '../../room/track/options';\nimport { ENCRYPTION_ALGORITHM, IV_LENGTH, UNENCRYPTED_BYTES } from '../constants';\nimport { CryptorError, CryptorErrorReason } from '../errors';\nimport { type CryptorCallbacks, CryptorEvent } from '../events';\nimport type { DecodeRatchetOptions, KeyProviderOptions, KeySet } from '../types';\nimport { deriveKeys, isVideoFrame, needsRbspUnescaping, parseRbsp, writeRbsp } from '../utils';\nimport type { ParticipantKeyHandler } from './ParticipantKeyHandler';\nimport { SifGuard } from './SifGuard';\n\nexport const encryptionEnabledMap: Map<string, boolean> = new Map();\n\nexport interface FrameCryptorConstructor {\n  new (opts?: unknown): BaseFrameCryptor;\n}\n\nexport interface TransformerInfo {\n  readable: ReadableStream;\n  writable: WritableStream;\n  transformer: TransformStream;\n  abortController: AbortController;\n}\n\nexport class BaseFrameCryptor extends (EventEmitter as new () => TypedEventEmitter<CryptorCallbacks>) {\n  protected encodeFunction(\n    encodedFrame: RTCEncodedVideoFrame | RTCEncodedAudioFrame,\n    controller: TransformStreamDefaultController,\n  ): Promise<any> {\n    throw Error('not implemented for subclass');\n  }\n\n  protected decodeFunction(\n    encodedFrame: RTCEncodedVideoFrame | RTCEncodedAudioFrame,\n    controller: TransformStreamDefaultController,\n  ): Promise<any> {\n    throw Error('not implemented for subclass');\n  }\n}\n\n/**\n * Cryptor is responsible for en-/decrypting media frames.\n * Each Cryptor instance is responsible for en-/decrypting a single mediaStreamTrack.\n */\nexport class FrameCryptor extends BaseFrameCryptor {\n  private sendCounts: Map<number, number>;\n\n  private participantIdentity: string | undefined;\n\n  private trackId: string | undefined;\n\n  private keys: ParticipantKeyHandler;\n\n  private videoCodec?: VideoCodec;\n\n  private rtpMap: Map<number, VideoCodec>;\n\n  private keyProviderOptions: KeyProviderOptions;\n\n  /**\n   * used for detecting server injected unencrypted frames\n   */\n  private sifTrailer: Uint8Array;\n\n  private sifGuard: SifGuard;\n\n  private detectedCodec?: VideoCodec;\n\n  constructor(opts: {\n    keys: ParticipantKeyHandler;\n    participantIdentity: string;\n    keyProviderOptions: KeyProviderOptions;\n    sifTrailer?: Uint8Array;\n  }) {\n    super();\n    this.sendCounts = new Map();\n    this.keys = opts.keys;\n    this.participantIdentity = opts.participantIdentity;\n    this.rtpMap = new Map();\n    this.keyProviderOptions = opts.keyProviderOptions;\n    this.sifTrailer = opts.sifTrailer ?? Uint8Array.from([]);\n    this.sifGuard = new SifGuard();\n  }\n\n  private get logContext() {\n    return {\n      participant: this.participantIdentity,\n      mediaTrackId: this.trackId,\n      fallbackCodec: this.videoCodec,\n    };\n  }\n\n  /**\n   * Assign a different participant to the cryptor.\n   * useful for transceiver re-use\n   * @param id\n   * @param keys\n   */\n  setParticipant(id: string, keys: ParticipantKeyHandler) {\n    workerLogger.debug('setting new participant on cryptor', {\n      ...this.logContext,\n      participant: id,\n    });\n    if (this.participantIdentity) {\n      workerLogger.error(\n        'cryptor has already a participant set, participant should have been unset before',\n        {\n          ...this.logContext,\n        },\n      );\n    }\n    this.participantIdentity = id;\n    this.keys = keys;\n    this.sifGuard.reset();\n  }\n\n  unsetParticipant() {\n    workerLogger.debug('unsetting participant', this.logContext);\n    this.participantIdentity = undefined;\n  }\n\n  isEnabled() {\n    if (this.participantIdentity) {\n      return encryptionEnabledMap.get(this.participantIdentity);\n    } else {\n      return undefined;\n    }\n  }\n\n  getParticipantIdentity() {\n    return this.participantIdentity;\n  }\n\n  getTrackId() {\n    return this.trackId;\n  }\n\n  /**\n   * Update the video codec used by the mediaStreamTrack\n   * @param codec\n   */\n  setVideoCodec(codec: VideoCodec) {\n    this.videoCodec = codec;\n  }\n\n  /**\n   * rtp payload type map used for figuring out codec of payload type when encoding\n   * @param map\n   */\n  setRtpMap(map: Map<number, VideoCodec>) {\n    this.rtpMap = map;\n  }\n\n  setupTransform(\n    operation: 'encode' | 'decode',\n    readable: ReadableStream<RTCEncodedVideoFrame | RTCEncodedAudioFrame>,\n    writable: WritableStream<RTCEncodedVideoFrame | RTCEncodedAudioFrame>,\n    trackId: string,\n    codec?: VideoCodec,\n  ) {\n    if (codec) {\n      workerLogger.info('setting codec on cryptor to', { codec });\n      this.videoCodec = codec;\n    }\n\n    workerLogger.debug('Setting up frame cryptor transform', {\n      operation,\n      passedTrackId: trackId,\n      codec,\n      ...this.logContext,\n    });\n\n    const transformFn = operation === 'encode' ? this.encodeFunction : this.decodeFunction;\n    const transformStream = new TransformStream({\n      transform: transformFn.bind(this),\n    });\n\n    readable\n      .pipeThrough(transformStream)\n      .pipeTo(writable)\n      .catch((e) => {\n        workerLogger.warn(e);\n        this.emit(\n          CryptorEvent.Error,\n          e instanceof CryptorError\n            ? e\n            : new CryptorError(e.message, undefined, this.participantIdentity),\n        );\n      });\n    this.trackId = trackId;\n  }\n\n  setSifTrailer(trailer: Uint8Array) {\n    workerLogger.debug('setting SIF trailer', { ...this.logContext, trailer });\n    this.sifTrailer = trailer;\n  }\n\n  /**\n   * Function that will be injected in a stream and will encrypt the given encoded frames.\n   *\n   * @param {RTCEncodedVideoFrame|RTCEncodedAudioFrame} encodedFrame - Encoded video frame.\n   * @param {TransformStreamDefaultController} controller - TransportStreamController.\n   *\n   * The VP8 payload descriptor described in\n   * https://tools.ietf.org/html/rfc7741#section-4.2\n   * is part of the RTP packet and not part of the frame and is not controllable by us.\n   * This is fine as the SFU keeps having access to it for routing.\n   *\n   * The encrypted frame is formed as follows:\n   * 1) Find unencrypted byte length, depending on the codec, frame type and kind.\n   * 2) Form the GCM IV for the frame as described above.\n   * 3) Encrypt the rest of the frame using AES-GCM.\n   * 4) Allocate space for the encrypted frame.\n   * 5) Copy the unencrypted bytes to the start of the encrypted frame.\n   * 6) Append the ciphertext to the encrypted frame.\n   * 7) Append the IV.\n   * 8) Append a single byte for the key identifier.\n   * 9) Enqueue the encrypted frame for sending.\n   */\n  protected async encodeFunction(\n    encodedFrame: RTCEncodedVideoFrame | RTCEncodedAudioFrame,\n    controller: TransformStreamDefaultController,\n  ) {\n    if (\n      !this.isEnabled() ||\n      // skip for encryption for empty dtx frames\n      encodedFrame.data.byteLength === 0\n    ) {\n      return controller.enqueue(encodedFrame);\n    }\n    const keySet = this.keys.getKeySet();\n    if (!keySet) {\n      this.emit(\n        CryptorEvent.Error,\n        new CryptorError(\n          `key set not found for ${\n            this.participantIdentity\n          } at index ${this.keys.getCurrentKeyIndex()}`,\n          CryptorErrorReason.MissingKey,\n          this.participantIdentity,\n        ),\n      );\n      return;\n    }\n    const { encryptionKey } = keySet;\n    const keyIndex = this.keys.getCurrentKeyIndex();\n\n    if (encryptionKey) {\n      const iv = this.makeIV(\n        encodedFrame.getMetadata().synchronizationSource ?? -1,\n        encodedFrame.timestamp,\n      );\n      let frameInfo = this.getUnencryptedBytes(encodedFrame);\n\n      // Ths is not encrypted and contains the VP8 payload descriptor or the Opus TOC byte.\n      const frameHeader = new Uint8Array(encodedFrame.data, 0, frameInfo.unencryptedBytes);\n\n      // Frame trailer contains the R|IV_LENGTH and key index\n      const frameTrailer = new Uint8Array(2);\n\n      frameTrailer[0] = IV_LENGTH;\n      frameTrailer[1] = keyIndex;\n\n      // Construct frame trailer. Similar to the frame header described in\n      // https://tools.ietf.org/html/draft-omara-sframe-00#section-4.2\n      // but we put it at the end.\n      //\n      // ---------+-------------------------+-+---------+----\n      // payload  |IV...(length = IV_LENGTH)|R|IV_LENGTH|KID |\n      // ---------+-------------------------+-+---------+----\n      try {\n        const cipherText = await crypto.subtle.encrypt(\n          {\n            name: ENCRYPTION_ALGORITHM,\n            iv,\n            additionalData: new Uint8Array(encodedFrame.data, 0, frameHeader.byteLength),\n          },\n          encryptionKey,\n          new Uint8Array(encodedFrame.data, frameInfo.unencryptedBytes),\n        );\n\n        let newDataWithoutHeader = new Uint8Array(\n          cipherText.byteLength + iv.byteLength + frameTrailer.byteLength,\n        );\n        newDataWithoutHeader.set(new Uint8Array(cipherText)); // add ciphertext.\n        newDataWithoutHeader.set(new Uint8Array(iv), cipherText.byteLength); // append IV.\n        newDataWithoutHeader.set(frameTrailer, cipherText.byteLength + iv.byteLength); // append frame trailer.\n\n        if (frameInfo.isH264) {\n          newDataWithoutHeader = writeRbsp(newDataWithoutHeader);\n        }\n\n        var newData = new Uint8Array(frameHeader.byteLength + newDataWithoutHeader.byteLength);\n        newData.set(frameHeader);\n        newData.set(newDataWithoutHeader, frameHeader.byteLength);\n\n        encodedFrame.data = newData.buffer;\n\n        return controller.enqueue(encodedFrame);\n      } catch (e: any) {\n        // TODO: surface this to the app.\n        workerLogger.error(e);\n      }\n    } else {\n      workerLogger.debug('failed to encrypt, emitting error', this.logContext);\n      this.emit(\n        CryptorEvent.Error,\n        new CryptorError(\n          `encryption key missing for encoding`,\n          CryptorErrorReason.MissingKey,\n          this.participantIdentity,\n        ),\n      );\n    }\n  }\n\n  /**\n   * Function that will be injected in a stream and will decrypt the given encoded frames.\n   *\n   * @param {RTCEncodedVideoFrame|RTCEncodedAudioFrame} encodedFrame - Encoded video frame.\n   * @param {TransformStreamDefaultController} controller - TransportStreamController.\n   */\n  protected async decodeFunction(\n    encodedFrame: RTCEncodedVideoFrame | RTCEncodedAudioFrame,\n    controller: TransformStreamDefaultController,\n  ) {\n    if (\n      !this.isEnabled() ||\n      // skip for decryption for empty dtx frames\n      encodedFrame.data.byteLength === 0\n    ) {\n      workerLogger.debug('skipping empty frame', this.logContext);\n      this.sifGuard.recordUserFrame();\n      return controller.enqueue(encodedFrame);\n    }\n\n    if (isFrameServerInjected(encodedFrame.data, this.sifTrailer)) {\n      workerLogger.debug('enqueue SIF', this.logContext);\n      this.sifGuard.recordSif();\n\n      if (this.sifGuard.isSifAllowed()) {\n        encodedFrame.data = encodedFrame.data.slice(\n          0,\n          encodedFrame.data.byteLength - this.sifTrailer.byteLength,\n        );\n        return controller.enqueue(encodedFrame);\n      } else {\n        workerLogger.warn('SIF limit reached, dropping frame');\n        return;\n      }\n    } else {\n      this.sifGuard.recordUserFrame();\n    }\n    const data = new Uint8Array(encodedFrame.data);\n    const keyIndex = data[encodedFrame.data.byteLength - 1];\n\n    if (this.keys.hasInvalidKeyAtIndex(keyIndex)) {\n      // drop frame\n      return;\n    }\n\n    if (this.keys.getKeySet(keyIndex)) {\n      try {\n        const decodedFrame = await this.decryptFrame(encodedFrame, keyIndex);\n        this.keys.decryptionSuccess(keyIndex);\n        if (decodedFrame) {\n          return controller.enqueue(decodedFrame);\n        }\n      } catch (error) {\n        if (error instanceof CryptorError && error.reason === CryptorErrorReason.InvalidKey) {\n          // emit an error if the key handler thinks we have a valid key\n          if (this.keys.hasValidKey) {\n            this.emit(CryptorEvent.Error, error);\n            this.keys.decryptionFailure(keyIndex);\n          }\n        } else {\n          workerLogger.warn('decoding frame failed', { error });\n        }\n      }\n    } else {\n      // emit an error if the key index is out of bounds but the key handler thinks we still have a valid key\n      workerLogger.warn(`skipping decryption due to missing key at index ${keyIndex}`);\n      this.emit(\n        CryptorEvent.Error,\n        new CryptorError(\n          `missing key at index ${keyIndex} for participant ${this.participantIdentity}`,\n          CryptorErrorReason.MissingKey,\n          this.participantIdentity,\n        ),\n      );\n      this.keys.decryptionFailure(keyIndex);\n    }\n  }\n\n  /**\n   * Function that will decrypt the given encoded frame. If the decryption fails, it will\n   * ratchet the key for up to RATCHET_WINDOW_SIZE times.\n   */\n  private async decryptFrame(\n    encodedFrame: RTCEncodedVideoFrame | RTCEncodedAudioFrame,\n    keyIndex: number,\n    initialMaterial: KeySet | undefined = undefined,\n    ratchetOpts: DecodeRatchetOptions = { ratchetCount: 0 },\n  ): Promise<RTCEncodedVideoFrame | RTCEncodedAudioFrame | undefined> {\n    const keySet = this.keys.getKeySet(keyIndex);\n    if (!ratchetOpts.encryptionKey && !keySet) {\n      throw new TypeError(`no encryption key found for decryption of ${this.participantIdentity}`);\n    }\n    let frameInfo = this.getUnencryptedBytes(encodedFrame);\n\n    // Construct frame trailer. Similar to the frame header described in\n    // https://tools.ietf.org/html/draft-omara-sframe-00#section-4.2\n    // but we put it at the end.\n    //\n    // ---------+-------------------------+-+---------+----\n    // payload  |IV...(length = IV_LENGTH)|R|IV_LENGTH|KID |\n    // ---------+-------------------------+-+---------+----\n\n    try {\n      const frameHeader = new Uint8Array(encodedFrame.data, 0, frameInfo.unencryptedBytes);\n      var encryptedData = new Uint8Array(\n        encodedFrame.data,\n        frameHeader.length,\n        encodedFrame.data.byteLength - frameHeader.length,\n      );\n      if (frameInfo.isH264 && needsRbspUnescaping(encryptedData)) {\n        encryptedData = parseRbsp(encryptedData);\n        const newUint8 = new Uint8Array(frameHeader.byteLength + encryptedData.byteLength);\n        newUint8.set(frameHeader);\n        newUint8.set(encryptedData, frameHeader.byteLength);\n        encodedFrame.data = newUint8.buffer;\n      }\n\n      const frameTrailer = new Uint8Array(encodedFrame.data, encodedFrame.data.byteLength - 2, 2);\n\n      const ivLength = frameTrailer[0];\n      const iv = new Uint8Array(\n        encodedFrame.data,\n        encodedFrame.data.byteLength - ivLength - frameTrailer.byteLength,\n        ivLength,\n      );\n\n      const cipherTextStart = frameHeader.byteLength;\n      const cipherTextLength =\n        encodedFrame.data.byteLength -\n        (frameHeader.byteLength + ivLength + frameTrailer.byteLength);\n\n      const plainText = await crypto.subtle.decrypt(\n        {\n          name: ENCRYPTION_ALGORITHM,\n          iv,\n          additionalData: new Uint8Array(encodedFrame.data, 0, frameHeader.byteLength),\n        },\n        ratchetOpts.encryptionKey ?? keySet!.encryptionKey,\n        new Uint8Array(encodedFrame.data, cipherTextStart, cipherTextLength),\n      );\n\n      const newData = new ArrayBuffer(frameHeader.byteLength + plainText.byteLength);\n      const newUint8 = new Uint8Array(newData);\n\n      newUint8.set(new Uint8Array(encodedFrame.data, 0, frameHeader.byteLength));\n      newUint8.set(new Uint8Array(plainText), frameHeader.byteLength);\n\n      encodedFrame.data = newData;\n\n      return encodedFrame;\n    } catch (error: any) {\n      if (this.keyProviderOptions.ratchetWindowSize > 0) {\n        if (ratchetOpts.ratchetCount < this.keyProviderOptions.ratchetWindowSize) {\n          workerLogger.debug(\n            `ratcheting key attempt ${ratchetOpts.ratchetCount} of ${\n              this.keyProviderOptions.ratchetWindowSize\n            }, for kind ${encodedFrame instanceof RTCEncodedAudioFrame ? 'audio' : 'video'}`,\n          );\n\n          let ratchetedKeySet: KeySet | undefined;\n          if ((initialMaterial ?? keySet) === this.keys.getKeySet(keyIndex)) {\n            // only ratchet if the currently set key is still the same as the one used to decrypt this frame\n            // if not, it might be that a different frame has already ratcheted and we try with that one first\n            const newMaterial = await this.keys.ratchetKey(keyIndex, false);\n\n            ratchetedKeySet = await deriveKeys(newMaterial, this.keyProviderOptions.ratchetSalt);\n          }\n\n          const frame = await this.decryptFrame(encodedFrame, keyIndex, initialMaterial || keySet, {\n            ratchetCount: ratchetOpts.ratchetCount + 1,\n            encryptionKey: ratchetedKeySet?.encryptionKey,\n          });\n          if (frame && ratchetedKeySet) {\n            // before updating the keys, make sure that the keySet used for this frame is still the same as the currently set key\n            // if it's not, a new key might have been set already, which we don't want to override\n            if ((initialMaterial ?? keySet) === this.keys.getKeySet(keyIndex)) {\n              this.keys.setKeySet(ratchetedKeySet, keyIndex, true);\n              // decryption was successful, set the new key index to reflect the ratcheted key set\n              this.keys.setCurrentKeyIndex(keyIndex);\n            }\n          }\n          return frame;\n        } else {\n          /**\n           * Because we only set a new key once decryption has been successful,\n           * we can be sure that we don't need to reset the key to the initial material at this point\n           * as the key has not been updated on the keyHandler instance\n           */\n\n          workerLogger.warn('maximum ratchet attempts exceeded');\n          throw new CryptorError(\n            `valid key missing for participant ${this.participantIdentity}`,\n            CryptorErrorReason.InvalidKey,\n            this.participantIdentity,\n          );\n        }\n      } else {\n        throw new CryptorError(\n          `Decryption failed: ${error.message}`,\n          CryptorErrorReason.InvalidKey,\n          this.participantIdentity,\n        );\n      }\n    }\n  }\n\n  /**\n   * Construct the IV used for AES-GCM and sent (in plain) with the packet similar to\n   * https://tools.ietf.org/html/rfc7714#section-8.1\n   * It concatenates\n   * - the 32 bit synchronization source (SSRC) given on the encoded frame,\n   * - the 32 bit rtp timestamp given on the encoded frame,\n   * - a send counter that is specific to the SSRC. Starts at a random number.\n   * The send counter is essentially the pictureId but we currently have to implement this ourselves.\n   * There is no XOR with a salt. Note that this IV leaks the SSRC to the receiver but since this is\n   * randomly generated and SFUs may not rewrite this is considered acceptable.\n   * The SSRC is used to allow demultiplexing multiple streams with the same key, as described in\n   *   https://tools.ietf.org/html/rfc3711#section-4.1.1\n   * The RTP timestamp is 32 bits and advances by the codec clock rate (90khz for video, 48khz for\n   * opus audio) every second. For video it rolls over roughly every 13 hours.\n   * The send counter will advance at the frame rate (30fps for video, 50fps for 20ms opus audio)\n   * every second. It will take a long time to roll over.\n   *\n   * See also https://developer.mozilla.org/en-US/docs/Web/API/AesGcmParams\n   */\n  private makeIV(synchronizationSource: number, timestamp: number) {\n    const iv = new ArrayBuffer(IV_LENGTH);\n    const ivView = new DataView(iv);\n\n    // having to keep our own send count (similar to a picture id) is not ideal.\n    if (!this.sendCounts.has(synchronizationSource)) {\n      // Initialize with a random offset, similar to the RTP sequence number.\n      this.sendCounts.set(synchronizationSource, Math.floor(Math.random() * 0xffff));\n    }\n\n    const sendCount = this.sendCounts.get(synchronizationSource) ?? 0;\n\n    ivView.setUint32(0, synchronizationSource);\n    ivView.setUint32(4, timestamp);\n    ivView.setUint32(8, timestamp - (sendCount % 0xffff));\n\n    this.sendCounts.set(synchronizationSource, sendCount + 1);\n\n    return iv;\n  }\n\n  private getUnencryptedBytes(frame: RTCEncodedVideoFrame | RTCEncodedAudioFrame): {\n    unencryptedBytes: number;\n    isH264: boolean;\n  } {\n    var frameInfo = { unencryptedBytes: 0, isH264: false };\n    if (isVideoFrame(frame)) {\n      let detectedCodec = this.getVideoCodec(frame) ?? this.videoCodec;\n      if (detectedCodec !== this.detectedCodec) {\n        workerLogger.debug('detected different codec', {\n          detectedCodec,\n          oldCodec: this.detectedCodec,\n          ...this.logContext,\n        });\n        this.detectedCodec = detectedCodec;\n      }\n\n      if (detectedCodec === 'av1') {\n        throw new Error(`${detectedCodec} is not yet supported for end to end encryption`);\n      }\n\n      if (detectedCodec === 'vp8') {\n        frameInfo.unencryptedBytes = UNENCRYPTED_BYTES[frame.type];\n      } else if (detectedCodec === 'vp9') {\n        frameInfo.unencryptedBytes = 0;\n        return frameInfo;\n      }\n\n      const data = new Uint8Array(frame.data);\n      try {\n        const naluIndices = findNALUIndices(data);\n\n        // if the detected codec is undefined we test whether it _looks_ like a h264 frame as a best guess\n        frameInfo.isH264 =\n          detectedCodec === 'h264' ||\n          naluIndices.some((naluIndex) =>\n            [NALUType.SLICE_IDR, NALUType.SLICE_NON_IDR].includes(parseNALUType(data[naluIndex])),\n          );\n\n        if (frameInfo.isH264) {\n          for (const index of naluIndices) {\n            let type = parseNALUType(data[index]);\n            switch (type) {\n              case NALUType.SLICE_IDR:\n              case NALUType.SLICE_NON_IDR:\n                frameInfo.unencryptedBytes = index + 2;\n                return frameInfo;\n              default:\n                break;\n            }\n          }\n          throw new TypeError('Could not find NALU');\n        }\n      } catch (e) {\n        // no op, we just continue and fallback to vp8\n      }\n\n      frameInfo.unencryptedBytes = UNENCRYPTED_BYTES[frame.type];\n      return frameInfo;\n    } else {\n      frameInfo.unencryptedBytes = UNENCRYPTED_BYTES.audio;\n      return frameInfo;\n    }\n  }\n\n  /**\n   * inspects frame payloadtype if available and maps it to the codec specified in rtpMap\n   */\n  private getVideoCodec(frame: RTCEncodedVideoFrame): VideoCodec | undefined {\n    if (this.rtpMap.size === 0) {\n      return undefined;\n    }\n    const payloadType = frame.getMetadata().payloadType;\n    const codec = payloadType ? this.rtpMap.get(payloadType) : undefined;\n    return codec;\n  }\n}\n\n/**\n * Slice the NALUs present in the supplied buffer, assuming it is already byte-aligned\n * code adapted from https://github.com/medooze/h264-frame-parser/blob/main/lib/NalUnits.ts to return indices only\n */\nexport function findNALUIndices(stream: Uint8Array): number[] {\n  const result: number[] = [];\n  let start = 0,\n    pos = 0,\n    searchLength = stream.length - 2;\n  while (pos < searchLength) {\n    // skip until end of current NALU\n    while (\n      pos < searchLength &&\n      !(stream[pos] === 0 && stream[pos + 1] === 0 && stream[pos + 2] === 1)\n    )\n      pos++;\n    if (pos >= searchLength) pos = stream.length;\n    // remove trailing zeros from current NALU\n    let end = pos;\n    while (end > start && stream[end - 1] === 0) end--;\n    // save current NALU\n    if (start === 0) {\n      if (end !== start) throw TypeError('byte stream contains leading data');\n    } else {\n      result.push(start);\n    }\n    // begin new NALU\n    start = pos = pos + 3;\n  }\n  return result;\n}\n\nexport function parseNALUType(startByte: number): NALUType {\n  return startByte & kNaluTypeMask;\n}\n\nconst kNaluTypeMask = 0x1f;\n\nexport enum NALUType {\n  /** Coded slice of a non-IDR picture */\n  SLICE_NON_IDR = 1,\n  /** Coded slice data partition A */\n  SLICE_PARTITION_A = 2,\n  /** Coded slice data partition B */\n  SLICE_PARTITION_B = 3,\n  /** Coded slice data partition C */\n  SLICE_PARTITION_C = 4,\n  /** Coded slice of an IDR picture */\n  SLICE_IDR = 5,\n  /** Supplemental enhancement information */\n  SEI = 6,\n  /** Sequence parameter set */\n  SPS = 7,\n  /** Picture parameter set */\n  PPS = 8,\n  /** Access unit delimiter */\n  AUD = 9,\n  /** End of sequence */\n  END_SEQ = 10,\n  /** End of stream */\n  END_STREAM = 11,\n  /** Filler data */\n  FILLER_DATA = 12,\n  /** Sequence parameter set extension */\n  SPS_EXT = 13,\n  /** Prefix NAL unit */\n  PREFIX_NALU = 14,\n  /** Subset sequence parameter set */\n  SUBSET_SPS = 15,\n  /** Depth parameter set */\n  DPS = 16,\n\n  // 17, 18 reserved\n\n  /** Coded slice of an auxiliary coded picture without partitioning */\n  SLICE_AUX = 19,\n  /** Coded slice extension */\n  SLICE_EXT = 20,\n  /** Coded slice extension for a depth view component or a 3D-AVC texture view component */\n  SLICE_LAYER_EXT = 21,\n\n  // 22, 23 reserved\n}\n\n/**\n * we use a magic frame trailer to detect whether a frame is injected\n * by the livekit server and thus to be treated as unencrypted\n * @internal\n */\nexport function isFrameServerInjected(frameData: ArrayBuffer, trailerBytes: Uint8Array): boolean {\n  if (trailerBytes.byteLength === 0) {\n    return false;\n  }\n  const frameTrailer = new Uint8Array(\n    frameData.slice(frameData.byteLength - trailerBytes.byteLength),\n  );\n  return trailerBytes.every((value, index) => value === frameTrailer[index]);\n}\n","import { EventEmitter } from 'events';\nimport type TypedEventEmitter from 'typed-emitter';\nimport { workerLogger } from '../../logger';\nimport { KeyHandlerEvent, type ParticipantKeyHandlerCallbacks } from '../events';\nimport type { KeyProviderOptions, KeySet } from '../types';\nimport { deriveKeys, importKey, ratchet } from '../utils';\n\n// TODO ParticipantKeyHandlers currently don't get destroyed on participant disconnect\n// we could do this by having a separate worker message on participant disconnected.\n\n/**\n * ParticipantKeyHandler is responsible for providing a cryptor instance with the\n * en-/decryption key of a participant. It assumes that all tracks of a specific participant\n * are encrypted with the same key.\n * Additionally it exposes a method to ratchet a key which can be used by the cryptor either automatically\n * if decryption fails or can be triggered manually on both sender and receiver side.\n *\n */\nexport class ParticipantKeyHandler extends (EventEmitter as new () => TypedEventEmitter<ParticipantKeyHandlerCallbacks>) {\n  private currentKeyIndex: number;\n\n  private cryptoKeyRing: Array<KeySet | undefined>;\n\n  private decryptionFailureCounts: Array<number>;\n\n  private keyProviderOptions: KeyProviderOptions;\n\n  private ratchetPromiseMap: Map<number, Promise<CryptoKey>>;\n\n  private participantIdentity: string;\n\n  /**\n   * true if the current key has not been marked as invalid\n   */\n  get hasValidKey(): boolean {\n    return !this.hasInvalidKeyAtIndex(this.currentKeyIndex);\n  }\n\n  constructor(participantIdentity: string, keyProviderOptions: KeyProviderOptions) {\n    super();\n    this.currentKeyIndex = 0;\n    if (keyProviderOptions.keyringSize < 1 || keyProviderOptions.keyringSize > 256) {\n      throw new TypeError('Keyring size needs to be between 1 and 256');\n    }\n    this.cryptoKeyRing = new Array(keyProviderOptions.keyringSize).fill(undefined);\n    this.decryptionFailureCounts = new Array(keyProviderOptions.keyringSize).fill(0);\n    this.keyProviderOptions = keyProviderOptions;\n    this.ratchetPromiseMap = new Map();\n    this.participantIdentity = participantIdentity;\n  }\n\n  /**\n   * Returns true if the key at the given index is marked as invalid.\n   *\n   * @param keyIndex the index of the key\n   */\n  hasInvalidKeyAtIndex(keyIndex: number): boolean {\n    return (\n      this.keyProviderOptions.failureTolerance >= 0 &&\n      this.decryptionFailureCounts[keyIndex] > this.keyProviderOptions.failureTolerance\n    );\n  }\n\n  /**\n   * Informs the key handler that a decryption failure occurred for an encryption key.\n   * @internal\n   * @param keyIndex the key index for which the failure occurred. Defaults to the current key index.\n   */\n  decryptionFailure(keyIndex: number = this.currentKeyIndex): void {\n    if (this.keyProviderOptions.failureTolerance < 0) {\n      return;\n    }\n\n    this.decryptionFailureCounts[keyIndex] += 1;\n\n    if (this.decryptionFailureCounts[keyIndex] > this.keyProviderOptions.failureTolerance) {\n      workerLogger.warn(\n        `key for ${this.participantIdentity} at index ${keyIndex} is being marked as invalid`,\n      );\n    }\n  }\n\n  /**\n   * Informs the key handler that a frame was successfully decrypted using an encryption key.\n   * @internal\n   * @param keyIndex the key index for which the success occurred. Defaults to the current key index.\n   */\n  decryptionSuccess(keyIndex: number = this.currentKeyIndex): void {\n    this.resetKeyStatus(keyIndex);\n  }\n\n  /**\n   * Call this after user initiated ratchet or a new key has been set in order to make sure to mark potentially\n   * invalid keys as valid again\n   *\n   * @param keyIndex the index of the key. Defaults to the current key index.\n   */\n  resetKeyStatus(keyIndex?: number): void {\n    if (keyIndex === undefined) {\n      this.decryptionFailureCounts.fill(0);\n    } else {\n      this.decryptionFailureCounts[keyIndex] = 0;\n    }\n  }\n\n  /**\n   * Ratchets the current key (or the one at keyIndex if provided) and\n   * returns the ratcheted material\n   * if `setKey` is true (default), it will also set the ratcheted key directly on the crypto key ring\n   * @param keyIndex\n   * @param setKey\n   */\n  ratchetKey(keyIndex?: number, setKey = true): Promise<CryptoKey> {\n    const currentKeyIndex = keyIndex ?? this.getCurrentKeyIndex();\n\n    const existingPromise = this.ratchetPromiseMap.get(currentKeyIndex);\n    if (typeof existingPromise !== 'undefined') {\n      return existingPromise;\n    }\n    const ratchetPromise = new Promise<CryptoKey>(async (resolve, reject) => {\n      try {\n        const keySet = this.getKeySet(currentKeyIndex);\n        if (!keySet) {\n          throw new TypeError(\n            `Cannot ratchet key without a valid keyset of participant ${this.participantIdentity}`,\n          );\n        }\n        const currentMaterial = keySet.material;\n        const newMaterial = await importKey(\n          await ratchet(currentMaterial, this.keyProviderOptions.ratchetSalt),\n          currentMaterial.algorithm.name,\n          'derive',\n        );\n\n        if (setKey) {\n          await this.setKeyFromMaterial(newMaterial, currentKeyIndex, true);\n          this.emit(\n            KeyHandlerEvent.KeyRatcheted,\n            newMaterial,\n            this.participantIdentity,\n            currentKeyIndex,\n          );\n        }\n        resolve(newMaterial);\n      } catch (e) {\n        reject(e);\n      } finally {\n        this.ratchetPromiseMap.delete(currentKeyIndex);\n      }\n    });\n    this.ratchetPromiseMap.set(currentKeyIndex, ratchetPromise);\n    return ratchetPromise;\n  }\n\n  /**\n   * takes in a key material with `deriveBits` and `deriveKey` set as key usages\n   * and derives encryption keys from the material and sets it on the key ring buffer\n   * together with the material\n   * also resets the valid key property and updates the currentKeyIndex\n   */\n  async setKey(material: CryptoKey, keyIndex = 0) {\n    await this.setKeyFromMaterial(material, keyIndex);\n    this.resetKeyStatus(keyIndex);\n  }\n\n  /**\n   * takes in a key material with `deriveBits` and `deriveKey` set as key usages\n   * and derives encryption keys from the material and sets it on the key ring buffers\n   * together with the material\n   * also updates the currentKeyIndex\n   */\n  async setKeyFromMaterial(material: CryptoKey, keyIndex: number, emitRatchetEvent = false) {\n    const keySet = await deriveKeys(material, this.keyProviderOptions.ratchetSalt);\n    const newIndex = keyIndex >= 0 ? keyIndex % this.cryptoKeyRing.length : this.currentKeyIndex;\n    workerLogger.debug(`setting new key with index ${keyIndex}`, {\n      usage: material.usages,\n      algorithm: material.algorithm,\n      ratchetSalt: this.keyProviderOptions.ratchetSalt,\n    });\n    this.setKeySet(keySet, newIndex, emitRatchetEvent);\n    if (newIndex >= 0) this.currentKeyIndex = newIndex;\n  }\n\n  setKeySet(keySet: KeySet, keyIndex: number, emitRatchetEvent = false) {\n    this.cryptoKeyRing[keyIndex % this.cryptoKeyRing.length] = keySet;\n\n    if (emitRatchetEvent) {\n      this.emit(KeyHandlerEvent.KeyRatcheted, keySet.material, this.participantIdentity, keyIndex);\n    }\n  }\n\n  async setCurrentKeyIndex(index: number) {\n    this.currentKeyIndex = index % this.cryptoKeyRing.length;\n    this.resetKeyStatus(index);\n  }\n\n  getCurrentKeyIndex() {\n    return this.currentKeyIndex;\n  }\n\n  /**\n   * returns currently used KeySet or the one at `keyIndex` if provided\n   * @param keyIndex\n   * @returns\n   */\n  getKeySet(keyIndex?: number) {\n    return this.cryptoKeyRing[keyIndex ?? this.currentKeyIndex];\n  }\n}\n","import { workerLogger } from '../../logger';\nimport type { VideoCodec } from '../../room/track/options';\nimport { AsyncQueue } from '../../utils/AsyncQueue';\nimport { KEY_PROVIDER_DEFAULTS } from '../constants';\nimport { CryptorErrorReason } from '../errors';\nimport { CryptorEvent, KeyHandlerEvent } from '../events';\nimport type {\n  E2EEWorkerMessage,\n  ErrorMessage,\n  InitAck,\n  KeyProviderOptions,\n  RatchetMessage,\n  RatchetRequestMessage,\n} from '../types';\nimport { FrameCryptor, encryptionEnabledMap } from './FrameCryptor';\nimport { ParticipantKeyHandler } from './ParticipantKeyHandler';\n\nconst participantCryptors: FrameCryptor[] = [];\nconst participantKeys: Map<string, ParticipantKeyHandler> = new Map();\nlet sharedKeyHandler: ParticipantKeyHandler | undefined;\nlet messageQueue = new AsyncQueue();\n\nlet isEncryptionEnabled: boolean = false;\n\nlet useSharedKey: boolean = false;\n\nlet sifTrailer: Uint8Array | undefined;\n\nlet keyProviderOptions: KeyProviderOptions = KEY_PROVIDER_DEFAULTS;\n\nlet rtpMap: Map<number, VideoCodec> = new Map();\n\nworkerLogger.setDefaultLevel('info');\n\nonmessage = (ev) => {\n  messageQueue.run(async () => {\n    const { kind, data }: E2EEWorkerMessage = ev.data;\n\n    switch (kind) {\n      case 'init':\n        workerLogger.setLevel(data.loglevel);\n        workerLogger.info('worker initialized');\n        keyProviderOptions = data.keyProviderOptions;\n        useSharedKey = !!data.keyProviderOptions.sharedKey;\n        // acknowledge init successful\n        const ackMsg: InitAck = {\n          kind: 'initAck',\n          data: { enabled: isEncryptionEnabled },\n        };\n        postMessage(ackMsg);\n        break;\n      case 'enable':\n        setEncryptionEnabled(data.enabled, data.participantIdentity);\n        workerLogger.info(\n          `updated e2ee enabled status for ${data.participantIdentity} to ${data.enabled}`,\n        );\n        // acknowledge enable call successful\n        postMessage(ev.data);\n        break;\n      case 'decode':\n        let cryptor = getTrackCryptor(data.participantIdentity, data.trackId);\n        cryptor.setupTransform(\n          kind,\n          data.readableStream,\n          data.writableStream,\n          data.trackId,\n          data.codec,\n        );\n        break;\n      case 'encode':\n        let pubCryptor = getTrackCryptor(data.participantIdentity, data.trackId);\n        pubCryptor.setupTransform(\n          kind,\n          data.readableStream,\n          data.writableStream,\n          data.trackId,\n          data.codec,\n        );\n        break;\n      case 'setKey':\n        if (useSharedKey) {\n          await setSharedKey(data.key, data.keyIndex);\n        } else if (data.participantIdentity) {\n          workerLogger.info(\n            `set participant sender key ${data.participantIdentity} index ${data.keyIndex}`,\n          );\n          await getParticipantKeyHandler(data.participantIdentity).setKey(data.key, data.keyIndex);\n        } else {\n          workerLogger.error('no participant Id was provided and shared key usage is disabled');\n        }\n        break;\n      case 'removeTransform':\n        unsetCryptorParticipant(data.trackId, data.participantIdentity);\n        break;\n      case 'updateCodec':\n        getTrackCryptor(data.participantIdentity, data.trackId).setVideoCodec(data.codec);\n        break;\n      case 'setRTPMap':\n        // this is only used for the local participant\n        rtpMap = data.map;\n        participantCryptors.forEach((cr) => {\n          if (cr.getParticipantIdentity() === data.participantIdentity) {\n            cr.setRtpMap(data.map);\n          }\n        });\n        break;\n      case 'ratchetRequest':\n        handleRatchetRequest(data);\n        break;\n      case 'setSifTrailer':\n        handleSifTrailer(data.trailer);\n        break;\n      default:\n        break;\n    }\n  });\n};\n\nasync function handleRatchetRequest(data: RatchetRequestMessage['data']) {\n  if (useSharedKey) {\n    const keyHandler = getSharedKeyHandler();\n    await keyHandler.ratchetKey(data.keyIndex);\n    keyHandler.resetKeyStatus();\n  } else if (data.participantIdentity) {\n    const keyHandler = getParticipantKeyHandler(data.participantIdentity);\n    await keyHandler.ratchetKey(data.keyIndex);\n    keyHandler.resetKeyStatus();\n  } else {\n    workerLogger.error(\n      'no participant Id was provided for ratchet request and shared key usage is disabled',\n    );\n  }\n}\n\nfunction getTrackCryptor(participantIdentity: string, trackId: string) {\n  let cryptors = participantCryptors.filter((c) => c.getTrackId() === trackId);\n  if (cryptors.length > 1) {\n    const debugInfo = cryptors\n      .map((c) => {\n        return { participant: c.getParticipantIdentity() };\n      })\n      .join(',');\n    workerLogger.error(\n      `Found multiple cryptors for the same trackID ${trackId}. target participant: ${participantIdentity} `,\n      { participants: debugInfo },\n    );\n  }\n  let cryptor = cryptors[0];\n  if (!cryptor) {\n    workerLogger.info('creating new cryptor for', { participantIdentity });\n    if (!keyProviderOptions) {\n      throw Error('Missing keyProvider options');\n    }\n    cryptor = new FrameCryptor({\n      participantIdentity,\n      keys: getParticipantKeyHandler(participantIdentity),\n      keyProviderOptions,\n      sifTrailer,\n    });\n    cryptor.setRtpMap(rtpMap);\n    setupCryptorErrorEvents(cryptor);\n    participantCryptors.push(cryptor);\n  } else if (participantIdentity !== cryptor.getParticipantIdentity()) {\n    // assign new participant id to track cryptor and pass in correct key handler\n    cryptor.setParticipant(participantIdentity, getParticipantKeyHandler(participantIdentity));\n  }\n\n  return cryptor;\n}\n\nfunction getParticipantKeyHandler(participantIdentity: string) {\n  if (useSharedKey) {\n    return getSharedKeyHandler();\n  }\n  let keys = participantKeys.get(participantIdentity);\n  if (!keys) {\n    keys = new ParticipantKeyHandler(participantIdentity, keyProviderOptions);\n    keys.on(KeyHandlerEvent.KeyRatcheted, emitRatchetedKeys);\n    participantKeys.set(participantIdentity, keys);\n  }\n  return keys;\n}\n\nfunction getSharedKeyHandler() {\n  if (!sharedKeyHandler) {\n    workerLogger.debug('creating new shared key handler');\n    sharedKeyHandler = new ParticipantKeyHandler('shared-key', keyProviderOptions);\n  }\n  return sharedKeyHandler;\n}\n\nfunction unsetCryptorParticipant(trackId: string, participantIdentity: string) {\n  const cryptors = participantCryptors.filter(\n    (c) => c.getParticipantIdentity() === participantIdentity && c.getTrackId() === trackId,\n  );\n  if (cryptors.length > 1) {\n    workerLogger.error('Found multiple cryptors for the same participant and trackID combination', {\n      trackId,\n      participantIdentity,\n    });\n  }\n  const cryptor = cryptors[0];\n  if (!cryptor) {\n    workerLogger.warn('Could not unset participant on cryptor', { trackId, participantIdentity });\n  } else {\n    cryptor.unsetParticipant();\n  }\n}\n\nfunction setEncryptionEnabled(enable: boolean, participantIdentity: string) {\n  workerLogger.debug(`setting encryption enabled for all tracks of ${participantIdentity}`, {\n    enable,\n  });\n  encryptionEnabledMap.set(participantIdentity, enable);\n}\n\nasync function setSharedKey(key: CryptoKey, index?: number) {\n  workerLogger.info('set shared key', { index });\n  await getSharedKeyHandler().setKey(key, index);\n}\n\nfunction setupCryptorErrorEvents(cryptor: FrameCryptor) {\n  cryptor.on(CryptorEvent.Error, (error) => {\n    const msg: ErrorMessage = {\n      kind: 'error',\n      data: { error: new Error(`${CryptorErrorReason[error.reason]}: ${error.message}`) },\n    };\n    postMessage(msg);\n  });\n}\n\nfunction emitRatchetedKeys(material: CryptoKey, participantIdentity: string, keyIndex?: number) {\n  const msg: RatchetMessage = {\n    kind: `ratchetKey`,\n    data: {\n      participantIdentity,\n      keyIndex,\n      material,\n    },\n  };\n  postMessage(msg);\n}\n\nfunction handleSifTrailer(trailer: Uint8Array) {\n  sifTrailer = trailer;\n  participantCryptors.forEach((c) => {\n    c.setSifTrailer(trailer);\n  });\n}\n\n// Operations using RTCRtpScriptTransform.\n// @ts-ignore\nif (self.RTCTransformEvent) {\n  workerLogger.debug('setup transform event');\n  // @ts-ignore\n  self.onrtctransform = (event: RTCTransformEvent) => {\n    // @ts-ignore .transformer property is part of RTCTransformEvent\n    const transformer = event.transformer;\n    workerLogger.debug('transformer', transformer);\n    // @ts-ignore monkey patching non standard flag\n    transformer.handled = true;\n    const { kind, participantIdentity, trackId, codec } = transformer.options;\n    const cryptor = getTrackCryptor(participantIdentity, trackId);\n    workerLogger.debug('transform', { codec });\n    cryptor.setupTransform(kind, transformer.readable, transformer.writable, trackId, codec);\n  };\n}\n"],"names":["sharedKeyHandler","sifTrailer","definition","LogLevel","LoggerNames","QueueTaskStatus","ConnectionErrorReason","MediaDeviceFailure","CryptorErrorReason","KeyProviderEvent","EncryptionEvent","NALUType","KeyHandlerEvent","CryptorEvent","noop","undefinedType","isIE","window","navigator","test","userAgent","logMethods","_loggersByName","defaultLogger","bindMethod","obj","methodName","method","bind","Function","prototype","call","e","apply","arguments","traceForIE","console","log","trace","replaceLoggingMethods","level","getLevel","i","length","methodFactory","name","debug","levels","SILENT","enableLoggingWhenConsoleArrives","defaultMethodFactory","_level","_loggerName","realMethod","undefined","Logger","factory","inheritedLevel","defaultLevel","userLevel","self","storageKey","getPersistedLevel","storedLevel","localStorage","ignore","cookie","document","cookieName","encodeURIComponent","location","indexOf","exec","slice","normalizeLevel","input","toUpperCase","setLevel","persist","persistLevelIfPossible","levelNum","levelName","setDefaultLevel","resetLevel","clearPersistedLevel","removeItem","enableAll","TRACE","disableAll","rebuild","childName","initialLevel","getLogger","logger","_log","noConflict","getLoggers","module","exports","root","livekitLogger","Object","values","map","info","workerLogger","_","constructor","o","_locking","Promise","resolve","_locks","isLocked","lock","s","t","l","unlockNext","c","then","AsyncQueue","pendingTasks","Map","taskMutex","Mutex","nextTaskIndex","run","task","taskInfo","id","enqueuedAt","Date","now","status","WAITING","set","unlock","executedAt","RUNNING","COMPLETED","delete","flush","__awaiter","snapshot","Array","from","ENCRYPTION_ALGORITHM","UNENCRYPTED_BYTES","key","delta","audio","empty","LivekitError","Error","code","message","getFailure","error","NotFound","PermissionDenied","DeviceInUse","Other","CryptorError","reason","InternalError","participantIdentity","ReflectOwnKeys","R","Reflect","ReflectApply","target","receiver","args","ownKeys","getOwnPropertySymbols","getOwnPropertyNames","concat","NumberIsNaN","Number","isNaN","value","EventEmitter","init","eventsModule","once","emitter","reject","flags","errorListener","err","removeListener","resolver","eventTargetAgnosticAddListener","on","_events","_eventsCount","_maxListeners","defaultMaxListeners","checkListener","listener","_getMaxListeners","that","_addListener","type","prepend","events","create","newListener","emit","existing","unshift","push","m","warned","w","String","count","warn","onceWrapper","fired","wrapFn","_onceWrap","state","wrapped","_listeners","unwrap","evlistener","unwrapListeners","arr","ret","arrayClone","listenerCount","n","copy","addEventListener","wrapListener","arg","removeEventListener","defineProperty","enumerable","get","getPrototypeOf","setMaxListeners","getMaxListeners","doError","er","context","handler","len","listeners","addListener","prependListener","prependOnceListener","list","position","originalListener","shift","spliceOne","index","pop","off","removeAllListeners","keys","rawListeners","eventNames","getAlgoOptions","algorithmName","salt","encodedSalt","textEncoder","TextEncoder","encode","hash","ArrayBuffer","iterations","deriveKeys","material","algorithmOptions","algorithm","encryptionKey","crypto","subtle","deriveKey","SifGuard","consecutiveSifCount","lastSifReceivedAt","userFramesSinceSif","recordSif","_a","sifSequenceStartedAt","recordUserFrame","MAX_SIF_DURATION","reset","isSifAllowed","encryptionEnabledMap","BaseFrameCryptor","encodeFunction","encodedFrame","controller","decodeFunction","FrameCryptor","opts","sendCounts","rtpMap","keyProviderOptions","Uint8Array","sifGuard","logContext","participant","mediaTrackId","trackId","fallbackCodec","videoCodec","setParticipant","assign","unsetParticipant","isEnabled","getParticipantIdentity","getTrackId","setVideoCodec","codec","setRtpMap","setupTransform","operation","readable","writable","passedTrackId","transformStream","TransformStream","transform","transformFn","pipeThrough","pipeTo","catch","setSifTrailer","trailer","data","byteLength","enqueue","keySet","getKeySet","getCurrentKeyIndex","MissingKey","keyIndex","iv","makeIV","getMetadata","synchronizationSource","timestamp","frameInfo","getUnencryptedBytes","frameHeader","unencryptedBytes","frameTrailer","cipherText","encrypt","additionalData","newDataWithoutHeader","isH264","writeRbsp","data_in","dataOut","numConsecutiveZeros","byte","newData","buffer","isFrameServerInjected","frameData","trailerBytes","every","hasInvalidKeyAtIndex","decodedFrame","decryptFrame","decryptionSuccess","InvalidKey","hasValidKey","decryptionFailure","encodedFrame_1","keyIndex_1","_this","initialMaterial","ratchetOpts","ratchetCount","encryptedData","needsRbspUnescaping","parseRbsp","stream","newUint8","ivLength","cipherTextStart","cipherTextLength","plainText","decrypt","ratchetWindowSize","ratchetedKeySet","RTCEncodedAudioFrame","newMaterial","ratchetKey","ratchetSalt","frame","setKeySet","setCurrentKeyIndex","ivView","DataView","has","Math","floor","random","sendCount","setUint32","detectedCodec","getVideoCodec","oldCodec","naluIndices","findNALUIndices","result","start","pos","searchLength","end","TypeError","some","naluIndex","SLICE_IDR","SLICE_NON_IDR","includes","startByte","kNaluTypeMask","size","payloadType","ParticipantKeyHandler","currentKeyIndex","keyringSize","cryptoKeyRing","fill","decryptionFailureCounts","ratchetPromiseMap","failureTolerance","resetKeyStatus","setKey","existingPromise","ratchetPromise","currentMaterial","importKey","keyBytes_1","keyBytes","usage","ratchet","deriveBits","setKeyFromMaterial","KeyRatcheted","material_1","_this2","emitRatchetEvent","newIndex","usages","participantCryptors","participantKeys","messageQueue","useSharedKey","sharedKey","getTrackCryptor","cryptors","filter","debugInfo","join","participants","cryptor","getParticipantKeyHandler","setupCryptorErrorEvents","postMessage","kind","getSharedKeyHandler","emitRatchetedKeys","onmessage","ev","enable","loglevel","enabled","readableStream","writableStream","setSharedKey","unsetCryptorParticipant","forEach","cr","handleRatchetRequest","keyHandler","RTCTransformEvent","onrtctransform","event","transformer","handled","options"],"sourceRoot":""}